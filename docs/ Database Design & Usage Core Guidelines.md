# AI HR SaaS — Database Design & Usage Core Guidelines — Generated on 2025-06-18

## Core Database Design Principles

### 1. Identity and Primary Keys
* Use UUID primary keys generated by `gen_random_uuid()` for all tables
* Primary key columns should be named `id`
* Consider using VARCHAR(36) for foreign key references to reduce coupling between tables

### 2. Multi-Tenant Architecture
* Include `tenant_id` columns in business entity tables for data isolation
* Consider omitting `tenant_id` for system-wide reference tables (e.g., configuration, templates)
* Always filter queries by `tenant_id` when accessing tenant-specific data
* Index `tenant_id` as the first column in composite indexes for tenant-scoped queries

### 3. Audit Trail and Timestamps
* Include `created_at` and `updated_at` columns with `TIMESTAMPTZ` type
* Use `DEFAULT CURRENT_TIMESTAMP` and `server_onupdate=func.now()` for automated timestamp management
* Define audit fields as `NOT NULL` to ensure complete tracking

### 4. Soft-Delete Pattern
* Implement soft-delete through status fields rather than physical deletion
* Use standardized status values: `active`, `inactive`, `deleted`
* Filter out deleted records in default queries
* Create unique indexes with `WHERE status != 'deleted'` when business rules require uniqueness among active records

### 5. Field Design Principles
* Use snake_case for all column names
* Choose appropriate data types based on content characteristics:
  - VARCHAR(n) for strings with reasonable length limits
  - TEXT for large or variable-length content
  - BOOLEAN for binary flags
* Apply DEFAULT values to Boolean fields based on business logic, not as a universal rule
* Use NOT NULL constraints only when a field is truly required for business logic

### 6. Indexing Strategy
* Create indexes based on query patterns, not just because a field is a foreign key
* Prioritize indexes for:
  - Columns frequently used in WHERE clauses
  - Columns used in JOIN conditions
  - Columns used in ORDER BY clauses
  - Composite indexes for common multi-column queries
* Use specialized indexes for specific use cases:
  - GIN indexes for full-text search
  - HNSW indexes for vector similarity search
  - Partial indexes for filtered data subsets

### 7. Logging and Observability
* Design logging tables to capture essential operational data without excessive detail
* Include correlation IDs (like `trace_id`) to link related operations across tables
* Store foreign key references as VARCHAR(36) to reduce coupling with entity tables
* Make error-related fields nullable to avoid constraints during successful operations
* Track key performance metrics relevant to specific operation type

### 8. Documentation and Maintainability
* Add table-level comments explaining purpose and key relationships
* Include column comments explaining purpose and valid values
* Document business rules and constraints in comments
* Maintain consistency in naming conventions across the schema

### 9. Data Integrity and Constraints
* Apply constraints based on business requirements, not as a universal template
* Use CHECK constraints for validating data formats when applicable
* Consider the trade-off between strict constraints and flexibility
* Implement appropriate validation at the application layer for complex business rules

### 10. Performance Optimization
* Consider denormalization when join performance is critical
* Use appropriate data types to minimize storage requirements
* Design for query patterns rather than theoretical purity
* Consider partitioning strategies for very large tables
* Balance normalization with performance requirements

## Decision Framework

When designing new tables, ask these questions:

1. **Identity**: Does this table need a UUID primary key? Will other tables reference it?
2. **Tenant Scope**: Is this data tenant-specific or system-wide?
3. **Audit Requirements**: Do we need to track when this data changes?
4. **Deletion Strategy**: Should this data be soft-deleted or physically removed?
5. **Query Patterns**: How will this data be accessed? What columns will be filtered?
6. **Relationships**: How does this table relate to others? What are the join patterns?
7. **Data Characteristics**: What type of data will be stored? Is it structured or flexible?
8. **Performance Requirements**: Are there specific performance requirements for this data?

This framework provides guidance while allowing flexibility for specific use cases and requirements.